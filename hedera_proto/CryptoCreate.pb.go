// Code generated by protoc-gen-go. DO NOT EDIT.
// source: CryptoCreate.proto

package hedera_proto

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Create a new account. After the account is created, the AccountID for it is in the receipt, or can be retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that. The account can then automatically generate records for large transfers into it or out of it, which each last for 25 hours. Records are generated for any transfer that exceeds the thresholds given here. This account is charged cryptocurrency for each record generated, so the thresholds are useful for limiting Record generation to happen only for large transactions. The Key field is the key used to sign transactions for this account. If the account has receiverSigRequired set to true, then all cryptocurrency transfers must be signed by this account's key, both for transfers in and out. If it is false, then only transfers out have to be signed by it. When the account is created, the payer account is charged enough hbars so that the new account will not expire for the next autoRenewPeriod seconds. When it reaches the expiration time, the new account will then be automatically charged to renew for another autoRenewPeriod seconds. If it does not have enough hbars to renew for that long, then the remaining hbars are used to extend its expiration as long as possible. If it is has a zero balance when it expires, then it is deleted. This transaction must be signed by the payer account. If receiverSigRequired is false, then the transaction does not have to be signed by the keys in the keys field. If it is true, then it must be signed by them, in addition to the keys of the payer account.
//
// An entity (account, file, or smart contract instance) must be created in a particular realm. If the realmID is left null, then a new realm will be created with the given admin key. If a new realm has a null adminKey, then anyone can create/modify/delete entities in that realm. But if an admin key is given, then any transaction to create/modify/delete an entity in that realm must be signed by that key, though anyone can still call functions on smart contract instances that exist in that realm. A realm ceases to exist when everything within it has expired and no longer exists.
//
// The current API ignores shardID, realmID, and newRealmAdminKey, and creates everything in shard 0 and realm 0, with a null key. Future versions of the API will support multiple realms and multiple shards.
type CryptoCreateTransactionBody struct {
	Key                    *Key       `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	InitialBalance         uint64     `protobuf:"varint,2,opt,name=initialBalance,proto3" json:"initialBalance,omitempty"`
	ProxyAccountID         *AccountID `protobuf:"bytes,3,opt,name=proxyAccountID,proto3" json:"proxyAccountID,omitempty"`
	SendRecordThreshold    uint64     `protobuf:"varint,6,opt,name=sendRecordThreshold,proto3" json:"sendRecordThreshold,omitempty"`
	ReceiveRecordThreshold uint64     `protobuf:"varint,7,opt,name=receiveRecordThreshold,proto3" json:"receiveRecordThreshold,omitempty"`
	ReceiverSigRequired    bool       `protobuf:"varint,8,opt,name=receiverSigRequired,proto3" json:"receiverSigRequired,omitempty"`
	AutoRenewPeriod        *Duration  `protobuf:"bytes,9,opt,name=autoRenewPeriod,proto3" json:"autoRenewPeriod,omitempty"`
	ShardID                *ShardID   `protobuf:"bytes,10,opt,name=shardID,proto3" json:"shardID,omitempty"`
	RealmID                *RealmID   `protobuf:"bytes,11,opt,name=realmID,proto3" json:"realmID,omitempty"`
	NewRealmAdminKey       *Key       `protobuf:"bytes,12,opt,name=newRealmAdminKey,proto3" json:"newRealmAdminKey,omitempty"`
	XXX_NoUnkeyedLiteral   struct{}   `json:"-"`
	XXX_unrecognized       []byte     `json:"-"`
	XXX_sizecache          int32      `json:"-"`
}

func (m *CryptoCreateTransactionBody) Reset()         { *m = CryptoCreateTransactionBody{} }
func (m *CryptoCreateTransactionBody) String() string { return proto.CompactTextString(m) }
func (*CryptoCreateTransactionBody) ProtoMessage()    {}
func (*CryptoCreateTransactionBody) Descriptor() ([]byte, []int) {
	return fileDescriptor_89b414cfdad72647, []int{0}
}

func (m *CryptoCreateTransactionBody) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CryptoCreateTransactionBody.Unmarshal(m, b)
}
func (m *CryptoCreateTransactionBody) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CryptoCreateTransactionBody.Marshal(b, m, deterministic)
}
func (m *CryptoCreateTransactionBody) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CryptoCreateTransactionBody.Merge(m, src)
}
func (m *CryptoCreateTransactionBody) XXX_Size() int {
	return xxx_messageInfo_CryptoCreateTransactionBody.Size(m)
}
func (m *CryptoCreateTransactionBody) XXX_DiscardUnknown() {
	xxx_messageInfo_CryptoCreateTransactionBody.DiscardUnknown(m)
}

var xxx_messageInfo_CryptoCreateTransactionBody proto.InternalMessageInfo

func (m *CryptoCreateTransactionBody) GetKey() *Key {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *CryptoCreateTransactionBody) GetInitialBalance() uint64 {
	if m != nil {
		return m.InitialBalance
	}
	return 0
}

func (m *CryptoCreateTransactionBody) GetProxyAccountID() *AccountID {
	if m != nil {
		return m.ProxyAccountID
	}
	return nil
}

func (m *CryptoCreateTransactionBody) GetSendRecordThreshold() uint64 {
	if m != nil {
		return m.SendRecordThreshold
	}
	return 0
}

func (m *CryptoCreateTransactionBody) GetReceiveRecordThreshold() uint64 {
	if m != nil {
		return m.ReceiveRecordThreshold
	}
	return 0
}

func (m *CryptoCreateTransactionBody) GetReceiverSigRequired() bool {
	if m != nil {
		return m.ReceiverSigRequired
	}
	return false
}

func (m *CryptoCreateTransactionBody) GetAutoRenewPeriod() *Duration {
	if m != nil {
		return m.AutoRenewPeriod
	}
	return nil
}

func (m *CryptoCreateTransactionBody) GetShardID() *ShardID {
	if m != nil {
		return m.ShardID
	}
	return nil
}

func (m *CryptoCreateTransactionBody) GetRealmID() *RealmID {
	if m != nil {
		return m.RealmID
	}
	return nil
}

func (m *CryptoCreateTransactionBody) GetNewRealmAdminKey() *Key {
	if m != nil {
		return m.NewRealmAdminKey
	}
	return nil
}

func init() {
	proto.RegisterType((*CryptoCreateTransactionBody)(nil), "proto.CryptoCreateTransactionBody")
}

func init() { proto.RegisterFile("CryptoCreate.proto", fileDescriptor_89b414cfdad72647) }

var fileDescriptor_89b414cfdad72647 = []byte{
	// 360 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x91, 0xb1, 0x8f, 0xd3, 0x30,
	0x14, 0xc6, 0x15, 0xee, 0xb8, 0x3b, 0x7c, 0xa7, 0x5c, 0x65, 0x24, 0x64, 0x15, 0x86, 0xaa, 0x03,
	0xca, 0x14, 0x21, 0x40, 0x15, 0x8c, 0x4d, 0xb3, 0x54, 0x5d, 0x2a, 0xb7, 0x13, 0x0b, 0x7a, 0xd8,
	0x4f, 0x8d, 0x21, 0xb5, 0xc3, 0x4b, 0xd2, 0x92, 0x8d, 0x3f, 0x1d, 0xc5, 0x49, 0x11, 0xa4, 0xbd,
	0xc9, 0xca, 0xf7, 0xfd, 0x7e, 0x7e, 0x7a, 0x31, 0xe3, 0x0b, 0x6a, 0x8a, 0xca, 0x2d, 0x08, 0xa1,
	0xc2, 0xb8, 0x20, 0x57, 0x39, 0xfe, 0xdc, 0x1f, 0xe3, 0x51, 0x02, 0xa5, 0x51, 0xdb, 0xa6, 0xc0,
	0xb2, 0x2b, 0xc6, 0x61, 0x5a, 0x13, 0x54, 0xc6, 0xd9, 0xee, 0x7b, 0xfa, 0xfb, 0x9a, 0xbd, 0xfe,
	0xd7, 0xdf, 0x12, 0xd8, 0x12, 0x54, 0x4b, 0x24, 0x4e, 0x37, 0xfc, 0x0d, 0xbb, 0xfa, 0x81, 0x8d,
	0x08, 0x26, 0x41, 0x74, 0xff, 0x9e, 0x75, 0x52, 0xbc, 0xc2, 0x46, 0xb6, 0x31, 0x7f, 0xcb, 0x42,
	0x63, 0x4d, 0x65, 0x20, 0x4f, 0x20, 0x07, 0xab, 0x50, 0x3c, 0x9b, 0x04, 0xd1, 0xb5, 0x1c, 0xa4,
	0xfc, 0x13, 0x0b, 0x0b, 0x72, 0xbf, 0x9a, 0xb9, 0x52, 0xae, 0xb6, 0xd5, 0x32, 0x15, 0x57, 0xfe,
	0xc2, 0x51, 0x7f, 0xe1, 0xdf, 0x5c, 0x0e, 0x38, 0xfe, 0x8e, 0xbd, 0x2c, 0xd1, 0x6a, 0x89, 0xca,
	0x91, 0xde, 0x66, 0x84, 0x65, 0xe6, 0x72, 0x2d, 0x6e, 0xfc, 0x98, 0x4b, 0x15, 0x9f, 0xb1, 0x57,
	0x84, 0x0a, 0xcd, 0x01, 0x87, 0xd2, 0xad, 0x97, 0x9e, 0x68, 0xdb, 0x49, 0x7d, 0x43, 0x1b, 0xb3,
	0x93, 0xf8, 0xb3, 0x36, 0x84, 0x5a, 0xdc, 0x4d, 0x82, 0xe8, 0x4e, 0x5e, 0xaa, 0xf8, 0x67, 0xf6,
	0x08, 0x75, 0xe5, 0x24, 0x5a, 0x3c, 0xae, 0x91, 0x8c, 0xd3, 0xe2, 0x85, 0x5f, 0xeb, 0xb1, 0x5f,
	0xeb, 0xf4, 0xaf, 0xe5, 0x90, 0xe3, 0x11, 0xbb, 0x2d, 0x33, 0x20, 0xbd, 0x4c, 0x05, 0xf3, 0x4a,
	0xd8, 0x2b, 0x9b, 0x2e, 0x95, 0xa7, 0xba, 0x25, 0x09, 0x21, 0xdf, 0x2f, 0x53, 0x71, 0xff, 0x1f,
	0x29, 0xbb, 0x54, 0x9e, 0x6a, 0x3e, 0x63, 0x23, 0x8b, 0x47, 0x1f, 0xcf, 0xf5, 0xde, 0xd8, 0x15,
	0x36, 0xe2, 0xe1, 0xec, 0xdd, 0xce, 0x98, 0xe4, 0x23, 0x9b, 0x2a, 0xb7, 0x8f, 0x33, 0xd4, 0x48,
	0x90, 0x41, 0x99, 0xed, 0x08, 0x8a, 0x2c, 0x86, 0xc2, 0xf4, 0xda, 0x77, 0x38, 0xc0, 0x3a, 0xf8,
	0xf2, 0xd0, 0x11, 0x5f, 0x7d, 0xf8, 0xed, 0xc6, 0x1f, 0x1f, 0xfe, 0x04, 0x00, 0x00, 0xff, 0xff,
	0xc4, 0x5e, 0xbc, 0xa4, 0x7e, 0x02, 0x00, 0x00,
}
