// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.24.0
// 	protoc        v3.12.3
// source: proto/CryptoAddClaim.proto

package proto

import (
	proto "github.com/golang/protobuf/proto"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// This is a compile-time assertion that a sufficiently up-to-date version
// of the legacy proto package is being used.
const _ = proto.ProtoPackageIsVersion4

// A hash (presumably of some kind of credential or certificate), along with a list of keys (each of which is either a primitive or a threshold key). Each of them must reach its threshold when signing the transaction, to attach this claim to this account. At least one of them must reach its threshold to delete this Claim from this account. This is intended to provide a revocation service: all the authorities agree to attach the hash, to attest to the fact that the credential or certificate is valid. Any one of the authorities can later delete the hash, to indicate that the credential has been revoked. In this way, any client can prove to a third party that any particular account has certain credentials, or to identity facts proved about it, and that none of them have been revoked yet.
type Claim struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	AccountID     *AccountID `protobuf:"bytes,1,opt,name=accountID,proto3" json:"accountID,omitempty"`         //the account to which the claim is attached
	Hash          []byte     `protobuf:"bytes,2,opt,name=hash,proto3" json:"hash,omitempty"`                   // 48 byte SHA-384 hash (presumably of some kind of credential or certificate)
	Keys          *KeyList   `protobuf:"bytes,3,opt,name=keys,proto3" json:"keys,omitempty"`                   // list of keys: all must sign the transaction to attach the claim, and any one of them can later delete it. Each "key" can actually be a threshold key containing multiple other keys (including other threshold keys).
	ClaimDuration *Duration  `protobuf:"bytes,5,opt,name=claimDuration,proto3" json:"claimDuration,omitempty"` // the duration for which the claim will remain valid
}

func (x *Claim) Reset() {
	*x = Claim{}
	if protoimpl.UnsafeEnabled {
		mi := &file_proto_CryptoAddClaim_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Claim) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Claim) ProtoMessage() {}

func (x *Claim) ProtoReflect() protoreflect.Message {
	mi := &file_proto_CryptoAddClaim_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Claim.ProtoReflect.Descriptor instead.
func (*Claim) Descriptor() ([]byte, []int) {
	return file_proto_CryptoAddClaim_proto_rawDescGZIP(), []int{0}
}

func (x *Claim) GetAccountID() *AccountID {
	if x != nil {
		return x.AccountID
	}
	return nil
}

func (x *Claim) GetHash() []byte {
	if x != nil {
		return x.Hash
	}
	return nil
}

func (x *Claim) GetKeys() *KeyList {
	if x != nil {
		return x.Keys
	}
	return nil
}

func (x *Claim) GetClaimDuration() *Duration {
	if x != nil {
		return x.ClaimDuration
	}
	return nil
}

// Attach the given hash to the given account. The hash can be deleted by the keys used to transfer money from the account. The hash can also be deleted by any one of the deleteKeys (where that one may itself be a threshold key made up of multiple keys). Therefore, this acts as a revocation service for claims about the account. External authorities may issue certificates or credentials of some kind that make a claim about this account. The account owner can then attach a hash of that claim to the account. The transaction that adds the claim will be signed by the owner of the account, and also by all the authorities that are attesting to the truth of that claim. If the claim ever ceases to be true, such as when a certificate is revoked, then any one of the listed authorities has the ability to delete it. The account owner also has the ability to delete it at any time.
//
// In this way, it acts as a revocation server, and the account owner can prove to any third party that the claim is still true for this account, by sending the third party the signed credential, and then having the third party query to discover whether the hash of that credential is still attached to the account.
//
// For a given account, each Claim must contain a different hash. To modify the list of keys in a Claim, the existing Claim should first be deleted, then the Claim with the new list of keys can be added.
type CryptoAddClaimTransactionBody struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Claim *Claim `protobuf:"bytes,3,opt,name=claim,proto3" json:"claim,omitempty"` // A hash of some credential/certificate, along with the keys that authorized it and are allowed to delete it
}

func (x *CryptoAddClaimTransactionBody) Reset() {
	*x = CryptoAddClaimTransactionBody{}
	if protoimpl.UnsafeEnabled {
		mi := &file_proto_CryptoAddClaim_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CryptoAddClaimTransactionBody) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CryptoAddClaimTransactionBody) ProtoMessage() {}

func (x *CryptoAddClaimTransactionBody) ProtoReflect() protoreflect.Message {
	mi := &file_proto_CryptoAddClaim_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CryptoAddClaimTransactionBody.ProtoReflect.Descriptor instead.
func (*CryptoAddClaimTransactionBody) Descriptor() ([]byte, []int) {
	return file_proto_CryptoAddClaim_proto_rawDescGZIP(), []int{1}
}

func (x *CryptoAddClaimTransactionBody) GetClaim() *Claim {
	if x != nil {
		return x.Claim
	}
	return nil
}

var File_proto_CryptoAddClaim_proto protoreflect.FileDescriptor

var file_proto_CryptoAddClaim_proto_rawDesc = []byte{
	0x0a, 0x1a, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f, 0x43, 0x72, 0x79, 0x70, 0x74, 0x6f, 0x41, 0x64,
	0x64, 0x43, 0x6c, 0x61, 0x69, 0x6d, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x05, 0x70, 0x72,
	0x6f, 0x74, 0x6f, 0x1a, 0x16, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f, 0x42, 0x61, 0x73, 0x69, 0x63,
	0x54, 0x79, 0x70, 0x65, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x14, 0x70, 0x72, 0x6f,
	0x74, 0x6f, 0x2f, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x70, 0x72, 0x6f, 0x74,
	0x6f, 0x22, 0xa6, 0x01, 0x0a, 0x05, 0x43, 0x6c, 0x61, 0x69, 0x6d, 0x12, 0x2e, 0x0a, 0x09, 0x61,
	0x63, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x49, 0x44, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x10,
	0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x41, 0x63, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x49, 0x44,
	0x52, 0x09, 0x61, 0x63, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x49, 0x44, 0x12, 0x12, 0x0a, 0x04, 0x68,
	0x61, 0x73, 0x68, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x04, 0x68, 0x61, 0x73, 0x68, 0x12,
	0x22, 0x0a, 0x04, 0x6b, 0x65, 0x79, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0e, 0x2e,
	0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x4b, 0x65, 0x79, 0x4c, 0x69, 0x73, 0x74, 0x52, 0x04, 0x6b,
	0x65, 0x79, 0x73, 0x12, 0x35, 0x0a, 0x0d, 0x63, 0x6c, 0x61, 0x69, 0x6d, 0x44, 0x75, 0x72, 0x61,
	0x74, 0x69, 0x6f, 0x6e, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0f, 0x2e, 0x70, 0x72, 0x6f,
	0x74, 0x6f, 0x2e, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x0d, 0x63, 0x6c, 0x61,
	0x69, 0x6d, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x22, 0x43, 0x0a, 0x1d, 0x43, 0x72,
	0x79, 0x70, 0x74, 0x6f, 0x41, 0x64, 0x64, 0x43, 0x6c, 0x61, 0x69, 0x6d, 0x54, 0x72, 0x61, 0x6e,
	0x73, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x42, 0x6f, 0x64, 0x79, 0x12, 0x22, 0x0a, 0x05, 0x63,
	0x6c, 0x61, 0x69, 0x6d, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0c, 0x2e, 0x70, 0x72, 0x6f,
	0x74, 0x6f, 0x2e, 0x43, 0x6c, 0x61, 0x69, 0x6d, 0x52, 0x05, 0x63, 0x6c, 0x61, 0x69, 0x6d, 0x42,
	0x48, 0x0a, 0x1a, 0x63, 0x6f, 0x6d, 0x2e, 0x68, 0x65, 0x64, 0x65, 0x72, 0x61, 0x2e, 0x68, 0x61,
	0x73, 0x68, 0x67, 0x72, 0x61, 0x70, 0x68, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x50, 0x01, 0x5a,
	0x28, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x68, 0x61, 0x73, 0x68,
	0x67, 0x72, 0x61, 0x70, 0x68, 0x2f, 0x68, 0x65, 0x64, 0x65, 0x72, 0x61, 0x2d, 0x73, 0x64, 0x6b,
	0x2d, 0x67, 0x6f, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f,
	0x33,
}

var (
	file_proto_CryptoAddClaim_proto_rawDescOnce sync.Once
	file_proto_CryptoAddClaim_proto_rawDescData = file_proto_CryptoAddClaim_proto_rawDesc
)

func file_proto_CryptoAddClaim_proto_rawDescGZIP() []byte {
	file_proto_CryptoAddClaim_proto_rawDescOnce.Do(func() {
		file_proto_CryptoAddClaim_proto_rawDescData = protoimpl.X.CompressGZIP(file_proto_CryptoAddClaim_proto_rawDescData)
	})
	return file_proto_CryptoAddClaim_proto_rawDescData
}

var file_proto_CryptoAddClaim_proto_msgTypes = make([]protoimpl.MessageInfo, 2)
var file_proto_CryptoAddClaim_proto_goTypes = []interface{}{
	(*Claim)(nil),                         // 0: proto.Claim
	(*CryptoAddClaimTransactionBody)(nil), // 1: proto.CryptoAddClaimTransactionBody
	(*AccountID)(nil),                     // 2: proto.AccountID
	(*KeyList)(nil),                       // 3: proto.KeyList
	(*Duration)(nil),                      // 4: proto.Duration
}
var file_proto_CryptoAddClaim_proto_depIdxs = []int32{
	2, // 0: proto.Claim.accountID:type_name -> proto.AccountID
	3, // 1: proto.Claim.keys:type_name -> proto.KeyList
	4, // 2: proto.Claim.claimDuration:type_name -> proto.Duration
	0, // 3: proto.CryptoAddClaimTransactionBody.claim:type_name -> proto.Claim
	4, // [4:4] is the sub-list for method output_type
	4, // [4:4] is the sub-list for method input_type
	4, // [4:4] is the sub-list for extension type_name
	4, // [4:4] is the sub-list for extension extendee
	0, // [0:4] is the sub-list for field type_name
}

func init() { file_proto_CryptoAddClaim_proto_init() }
func file_proto_CryptoAddClaim_proto_init() {
	if File_proto_CryptoAddClaim_proto != nil {
		return
	}
	file_proto_BasicTypes_proto_init()
	file_proto_Duration_proto_init()
	if !protoimpl.UnsafeEnabled {
		file_proto_CryptoAddClaim_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Claim); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_proto_CryptoAddClaim_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CryptoAddClaimTransactionBody); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_proto_CryptoAddClaim_proto_rawDesc,
			NumEnums:      0,
			NumMessages:   2,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_proto_CryptoAddClaim_proto_goTypes,
		DependencyIndexes: file_proto_CryptoAddClaim_proto_depIdxs,
		MessageInfos:      file_proto_CryptoAddClaim_proto_msgTypes,
	}.Build()
	File_proto_CryptoAddClaim_proto = out.File
	file_proto_CryptoAddClaim_proto_rawDesc = nil
	file_proto_CryptoAddClaim_proto_goTypes = nil
	file_proto_CryptoAddClaim_proto_depIdxs = nil
}
