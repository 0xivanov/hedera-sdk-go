// Code generated by protoc-gen-go. DO NOT EDIT.
// source: MirrorConsensusService.proto

package proto

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type MirrorConsensusTopicQuery struct {
	TopicID *TopicID `protobuf:"bytes,1,opt,name=topicID,proto3" json:"topicID,omitempty"`
	// Include messages which reached consensus on or after this time. Defaults to current time if not set.
	ConsensusStartTime *Timestamp `protobuf:"bytes,2,opt,name=consensusStartTime,proto3" json:"consensusStartTime,omitempty"`
	// Include messages which reached consensus before this time. If not set it will receive indefinitely.
	ConsensusEndTime *Timestamp `protobuf:"bytes,3,opt,name=consensusEndTime,proto3" json:"consensusEndTime,omitempty"`
	// The maximum number of messages to receive before stopping. If not set or set to zero it will return messages
	// indefinitely.
	Limit                uint64   `protobuf:"varint,4,opt,name=limit,proto3" json:"limit,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MirrorConsensusTopicQuery) Reset()         { *m = MirrorConsensusTopicQuery{} }
func (m *MirrorConsensusTopicQuery) String() string { return proto.CompactTextString(m) }
func (*MirrorConsensusTopicQuery) ProtoMessage()    {}
func (*MirrorConsensusTopicQuery) Descriptor() ([]byte, []int) {
	return fileDescriptor_293cc05c595f5829, []int{0}
}

func (m *MirrorConsensusTopicQuery) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MirrorConsensusTopicQuery.Unmarshal(m, b)
}
func (m *MirrorConsensusTopicQuery) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MirrorConsensusTopicQuery.Marshal(b, m, deterministic)
}
func (m *MirrorConsensusTopicQuery) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MirrorConsensusTopicQuery.Merge(m, src)
}
func (m *MirrorConsensusTopicQuery) XXX_Size() int {
	return xxx_messageInfo_MirrorConsensusTopicQuery.Size(m)
}
func (m *MirrorConsensusTopicQuery) XXX_DiscardUnknown() {
	xxx_messageInfo_MirrorConsensusTopicQuery.DiscardUnknown(m)
}

var xxx_messageInfo_MirrorConsensusTopicQuery proto.InternalMessageInfo

func (m *MirrorConsensusTopicQuery) GetTopicID() *TopicID {
	if m != nil {
		return m.TopicID
	}
	return nil
}

func (m *MirrorConsensusTopicQuery) GetConsensusStartTime() *Timestamp {
	if m != nil {
		return m.ConsensusStartTime
	}
	return nil
}

func (m *MirrorConsensusTopicQuery) GetConsensusEndTime() *Timestamp {
	if m != nil {
		return m.ConsensusEndTime
	}
	return nil
}

func (m *MirrorConsensusTopicQuery) GetLimit() uint64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

type MirrorConsensusTopicResponse struct {
	ConsensusTimestamp *Timestamp `protobuf:"bytes,1,opt,name=consensusTimestamp,proto3" json:"consensusTimestamp,omitempty"`
	// The message body originally in the ConsensusSubmitMessageTransactionBody. Message size will be less than 4K.
	Message              []byte   `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	RunningHash          []byte   `protobuf:"bytes,3,opt,name=runningHash,proto3" json:"runningHash,omitempty"`
	SequenceNumber       uint64   `protobuf:"varint,4,opt,name=sequenceNumber,proto3" json:"sequenceNumber,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MirrorConsensusTopicResponse) Reset()         { *m = MirrorConsensusTopicResponse{} }
func (m *MirrorConsensusTopicResponse) String() string { return proto.CompactTextString(m) }
func (*MirrorConsensusTopicResponse) ProtoMessage()    {}
func (*MirrorConsensusTopicResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_293cc05c595f5829, []int{1}
}

func (m *MirrorConsensusTopicResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MirrorConsensusTopicResponse.Unmarshal(m, b)
}
func (m *MirrorConsensusTopicResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MirrorConsensusTopicResponse.Marshal(b, m, deterministic)
}
func (m *MirrorConsensusTopicResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MirrorConsensusTopicResponse.Merge(m, src)
}
func (m *MirrorConsensusTopicResponse) XXX_Size() int {
	return xxx_messageInfo_MirrorConsensusTopicResponse.Size(m)
}
func (m *MirrorConsensusTopicResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MirrorConsensusTopicResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MirrorConsensusTopicResponse proto.InternalMessageInfo

func (m *MirrorConsensusTopicResponse) GetConsensusTimestamp() *Timestamp {
	if m != nil {
		return m.ConsensusTimestamp
	}
	return nil
}

func (m *MirrorConsensusTopicResponse) GetMessage() []byte {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *MirrorConsensusTopicResponse) GetRunningHash() []byte {
	if m != nil {
		return m.RunningHash
	}
	return nil
}

func (m *MirrorConsensusTopicResponse) GetSequenceNumber() uint64 {
	if m != nil {
		return m.SequenceNumber
	}
	return 0
}

func init() {
	proto.RegisterType((*MirrorConsensusTopicQuery)(nil), "proto.MirrorConsensusTopicQuery")
	proto.RegisterType((*MirrorConsensusTopicResponse)(nil), "proto.MirrorConsensusTopicResponse")
}

func init() { proto.RegisterFile("MirrorConsensusService.proto", fileDescriptor_293cc05c595f5829) }

var fileDescriptor_293cc05c595f5829 = []byte{
	// 328 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x51, 0x4f, 0x4b, 0xfb, 0x40,
	0x10, 0x65, 0x7f, 0xbf, 0xd6, 0xc2, 0xb6, 0xd4, 0xb2, 0x88, 0xc4, 0xe2, 0x21, 0x56, 0x94, 0x9e,
	0x82, 0xd4, 0xab, 0x07, 0xa9, 0x0a, 0x7a, 0x50, 0x34, 0xe6, 0xe2, 0x71, 0xb3, 0x1d, 0x9a, 0x05,
	0x77, 0x13, 0x67, 0x12, 0xa1, 0xdf, 0xcf, 0x6f, 0xe1, 0x97, 0x91, 0x6e, 0xfe, 0xa0, 0xfd, 0x77,
	0x5a, 0xde, 0xdb, 0x79, 0x33, 0xef, 0xcd, 0xf0, 0xe3, 0x47, 0x8d, 0x98, 0xe2, 0x4d, 0x6a, 0x09,
	0x2c, 0x15, 0xf4, 0x0a, 0xf8, 0xa9, 0x15, 0x04, 0x19, 0xa6, 0x79, 0x2a, 0xda, 0xee, 0x19, 0x0e,
	0xa6, 0x92, 0xb4, 0x8a, 0x16, 0x19, 0x50, 0xf9, 0x31, 0xdc, 0x8f, 0xb4, 0x01, 0xca, 0xa5, 0xc9,
	0x4a, 0x62, 0xf4, 0xcd, 0xf8, 0xd1, 0x4a, 0xab, 0x28, 0xcd, 0xb4, 0x7a, 0x29, 0x00, 0x17, 0x62,
	0xcc, 0x3b, 0xf9, 0x12, 0x3d, 0xdc, 0x7a, 0xcc, 0x67, 0xe3, 0xee, 0xa4, 0x5f, 0xca, 0x82, 0xa8,
	0x64, 0xc3, 0xfa, 0x5b, 0x5c, 0x73, 0xa1, 0x1a, 0x2f, 0xb9, 0xc4, 0x7c, 0x39, 0xc8, 0xfb, 0xe7,
	0x44, 0x83, 0x5a, 0x54, 0xcf, 0x0e, 0x37, 0xd4, 0x8a, 0x2b, 0x3e, 0x68, 0xd8, 0x3b, 0x3b, 0x73,
	0xfa, 0xff, 0x5b, 0xf4, 0x6b, 0x95, 0xe2, 0x80, 0xb7, 0xdf, 0xb5, 0xd1, 0xb9, 0xd7, 0xf2, 0xd9,
	0xb8, 0x15, 0x96, 0x60, 0xf4, 0xc5, 0xd6, 0x16, 0xe5, 0x9c, 0x87, 0x40, 0xd9, 0x92, 0xf8, 0x63,
	0xbb, 0x69, 0x5f, 0x65, 0xdd, 0x65, 0xbb, 0xe1, 0x84, 0xc7, 0x3b, 0x06, 0x88, 0xe4, 0xbc, 0x4c,
	0xdb, 0x0b, 0x6b, 0x28, 0x7c, 0xde, 0xc5, 0xc2, 0x5a, 0x6d, 0xe7, 0xf7, 0x92, 0x12, 0x97, 0xa5,
	0x17, 0xfe, 0xa6, 0xc4, 0x39, 0xef, 0x13, 0x7c, 0x14, 0x60, 0x15, 0x3c, 0x15, 0x26, 0x06, 0xac,
	0xdc, 0xaf, 0xb0, 0x13, 0xe2, 0x87, 0x9b, 0xcf, 0x2d, 0xde, 0x78, 0x9f, 0x8a, 0x98, 0x14, 0xea,
	0x18, 0x5c, 0x32, 0xe1, 0x57, 0xae, 0xb7, 0x1e, 0x75, 0x78, 0xba, 0xa3, 0xa2, 0x5e, 0xcc, 0x05,
	0x9b, 0x9e, 0xf1, 0x13, 0x95, 0x9a, 0x20, 0x81, 0x19, 0xa0, 0x0c, 0x12, 0x49, 0xc9, 0x1c, 0x65,
	0x96, 0x54, 0x62, 0xe3, 0xc4, 0xcf, 0x2c, 0xde, 0x73, 0xf8, 0xf2, 0x27, 0x00, 0x00, 0xff, 0xff,
	0x38, 0xd5, 0x8d, 0x65, 0x91, 0x02, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MirrorConsensusServiceClient is the client API for MirrorConsensusService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MirrorConsensusServiceClient interface {
	SubscribeTopic(ctx context.Context, in *MirrorConsensusTopicQuery, opts ...grpc.CallOption) (MirrorConsensusService_SubscribeTopicClient, error)
}

type mirrorConsensusServiceClient struct {
	cc *grpc.ClientConn
}

func NewMirrorConsensusServiceClient(cc *grpc.ClientConn) MirrorConsensusServiceClient {
	return &mirrorConsensusServiceClient{cc}
}

func (c *mirrorConsensusServiceClient) SubscribeTopic(ctx context.Context, in *MirrorConsensusTopicQuery, opts ...grpc.CallOption) (MirrorConsensusService_SubscribeTopicClient, error) {
	stream, err := c.cc.NewStream(ctx, &_MirrorConsensusService_serviceDesc.Streams[0], "/proto.MirrorConsensusService/subscribeTopic", opts...)
	if err != nil {
		return nil, err
	}
	x := &mirrorConsensusServiceSubscribeTopicClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type MirrorConsensusService_SubscribeTopicClient interface {
	Recv() (*MirrorConsensusTopicResponse, error)
	grpc.ClientStream
}

type mirrorConsensusServiceSubscribeTopicClient struct {
	grpc.ClientStream
}

func (x *mirrorConsensusServiceSubscribeTopicClient) Recv() (*MirrorConsensusTopicResponse, error) {
	m := new(MirrorConsensusTopicResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// MirrorConsensusServiceServer is the server API for MirrorConsensusService service.
type MirrorConsensusServiceServer interface {
	SubscribeTopic(*MirrorConsensusTopicQuery, MirrorConsensusService_SubscribeTopicServer) error
}

// UnimplementedMirrorConsensusServiceServer can be embedded to have forward compatible implementations.
type UnimplementedMirrorConsensusServiceServer struct {
}

func (*UnimplementedMirrorConsensusServiceServer) SubscribeTopic(req *MirrorConsensusTopicQuery, srv MirrorConsensusService_SubscribeTopicServer) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeTopic not implemented")
}

func RegisterMirrorConsensusServiceServer(s *grpc.Server, srv MirrorConsensusServiceServer) {
	s.RegisterService(&_MirrorConsensusService_serviceDesc, srv)
}

func _MirrorConsensusService_SubscribeTopic_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(MirrorConsensusTopicQuery)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MirrorConsensusServiceServer).SubscribeTopic(m, &mirrorConsensusServiceSubscribeTopicServer{stream})
}

type MirrorConsensusService_SubscribeTopicServer interface {
	Send(*MirrorConsensusTopicResponse) error
	grpc.ServerStream
}

type mirrorConsensusServiceSubscribeTopicServer struct {
	grpc.ServerStream
}

func (x *mirrorConsensusServiceSubscribeTopicServer) Send(m *MirrorConsensusTopicResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _MirrorConsensusService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "proto.MirrorConsensusService",
	HandlerType: (*MirrorConsensusServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "subscribeTopic",
			Handler:       _MirrorConsensusService_SubscribeTopic_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "MirrorConsensusService.proto",
}
