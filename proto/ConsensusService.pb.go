// Code generated by protoc-gen-go. DO NOT EDIT.
// source: ConsensusService.proto

package proto

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

func init() { proto.RegisterFile("ConsensusService.proto", fileDescriptor_167d5a1a8518367e) }

var fileDescriptor_167d5a1a8518367e = []byte{
	// 212 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0x12, 0x73, 0xce, 0xcf, 0x2b,
	0x4e, 0xcd, 0x2b, 0x2e, 0x2d, 0x0e, 0x4e, 0x2d, 0x2a, 0xcb, 0x4c, 0x4e, 0xd5, 0x2b, 0x28, 0xca,
	0x2f, 0xc9, 0x17, 0x62, 0x05, 0x53, 0x52, 0xdc, 0x81, 0xa5, 0xa9, 0x45, 0x95, 0x10, 0x31, 0x29,
	0xbe, 0xa0, 0xd4, 0xe2, 0x02, 0x90, 0x72, 0x28, 0x5f, 0x32, 0xa4, 0x28, 0x31, 0xaf, 0x38, 0x31,
	0xb9, 0x24, 0x33, 0x3f, 0x0f, 0x4d, 0x4a, 0x10, 0x49, 0x0a, 0x22, 0x64, 0xb4, 0x9f, 0x89, 0x4b,
	0x00, 0xdd, 0x32, 0x21, 0x5b, 0x2e, 0xee, 0xe4, 0xa2, 0xd4, 0xc4, 0x92, 0xd4, 0x90, 0xfc, 0x82,
	0xcc, 0x64, 0x21, 0x21, 0x88, 0x5a, 0x3d, 0x24, 0xdd, 0x52, 0x52, 0x98, 0x62, 0x30, 0xcb, 0x40,
	0xda, 0x4b, 0x0b, 0x52, 0x28, 0xd1, 0x9e, 0x92, 0x9a, 0x93, 0x4a, 0xae, 0x76, 0x5d, 0x2e, 0x9e,
	0xf4, 0xd4, 0x12, 0xb0, 0x5e, 0xcf, 0xbc, 0xb4, 0x7c, 0x21, 0x1e, 0xa8, 0x5a, 0x70, 0x98, 0x49,
	0xf1, 0x43, 0x79, 0x70, 0xe5, 0xf6, 0x5c, 0xbc, 0xc5, 0xa5, 0x49, 0xb9, 0x99, 0x25, 0xbe, 0xa9,
	0xc5, 0xc5, 0x89, 0xe9, 0xa9, 0xa4, 0xda, 0xe7, 0x24, 0xc3, 0x25, 0x95, 0x9c, 0x9f, 0xab, 0x97,
	0x91, 0x9a, 0x92, 0x5a, 0x94, 0xa8, 0x97, 0x91, 0x58, 0x9c, 0x91, 0x5e, 0x94, 0x58, 0x90, 0x01,
	0xd1, 0x91, 0xc4, 0x06, 0xa6, 0x8c, 0x01, 0x01, 0x00, 0x00, 0xff, 0xff, 0xa5, 0xb2, 0x3b, 0xda,
	0xd2, 0x01, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ConsensusServiceClient is the client API for ConsensusService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ConsensusServiceClient interface {
	// Create a topic to be used for consensus.
	// If an autoRenewAccount is specified, that account must also sign this transaction, and there must be an adminKey
	// specified.
	// Request is [ConsensusCreateTopicTransactionBody](#proto.ConsensusCreateTopicTransactionBody)
	CreateTopic(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*TransactionResponse, error)
	// Update a topic.
	// If there is no adminKey, the only authorized update (available to anyone) is to extend the expirationTime.
	// Otherwise transaction must be signed by the adminKey.
	// If a new autoRenewAccount is specified (not just being removed), that account must also sign the transaction.
	// Request is [ConsensusUpdateTopicTransactionBody](#proto.ConsensusUpdateTopicTransactionBody)
	UpdateTopic(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*TransactionResponse, error)
	// Delete a topic. No more transactions or queries on the topic (via HAPI) will succeed.
	// If an adminKey is set, this transaction must be signed by that key.
	// If there is no adminKey, this transaction will fail UNAUTHORIZED.
	// Request is [ConsensusDeleteTopicTransactionBody](#proto.ConsensusDeleteTopicTransactionBody)
	DeleteTopic(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*TransactionResponse, error)
	// Retrieve the latest state of a topic. This method is unrestricted and allowed on any topic by any payer account.
	// Deleted accounts will not be returned.
	// Request is [ConsensusGetTopicInfoQuery](#proto.ConsensusGetTopicInfoQuery)
	// Response is [ConsensusGetTopicInfoResponse](#proto.ConsensusGetTopicInfoResponse)
	GetTopicInfo(ctx context.Context, in *Query, opts ...grpc.CallOption) (*Response, error)
	// Submit a message for consensus.
	// Valid and authorized messages on valid topics will be ordered by the consensus service, gossipped to the
	// mirror net, and published (in order) to all subscribers (from the mirror net) on this topic.
	// The submitKey (if any) must sign this transaction.
	// Request is [ConsensusSubmitMessageTransactionBody](#proto.ConsensusSubmitMessageTransactionBody)
	SubmitMessage(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*TransactionResponse, error)
}

type consensusServiceClient struct {
	cc *grpc.ClientConn
}

func NewConsensusServiceClient(cc *grpc.ClientConn) ConsensusServiceClient {
	return &consensusServiceClient{cc}
}

func (c *consensusServiceClient) CreateTopic(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*TransactionResponse, error) {
	out := new(TransactionResponse)
	err := c.cc.Invoke(ctx, "/proto.ConsensusService/createTopic", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *consensusServiceClient) UpdateTopic(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*TransactionResponse, error) {
	out := new(TransactionResponse)
	err := c.cc.Invoke(ctx, "/proto.ConsensusService/updateTopic", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *consensusServiceClient) DeleteTopic(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*TransactionResponse, error) {
	out := new(TransactionResponse)
	err := c.cc.Invoke(ctx, "/proto.ConsensusService/deleteTopic", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *consensusServiceClient) GetTopicInfo(ctx context.Context, in *Query, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/proto.ConsensusService/getTopicInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *consensusServiceClient) SubmitMessage(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*TransactionResponse, error) {
	out := new(TransactionResponse)
	err := c.cc.Invoke(ctx, "/proto.ConsensusService/submitMessage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ConsensusServiceServer is the server API for ConsensusService service.
type ConsensusServiceServer interface {
	// Create a topic to be used for consensus.
	// If an autoRenewAccount is specified, that account must also sign this transaction, and there must be an adminKey
	// specified.
	// Request is [ConsensusCreateTopicTransactionBody](#proto.ConsensusCreateTopicTransactionBody)
	CreateTopic(context.Context, *Transaction) (*TransactionResponse, error)
	// Update a topic.
	// If there is no adminKey, the only authorized update (available to anyone) is to extend the expirationTime.
	// Otherwise transaction must be signed by the adminKey.
	// If a new autoRenewAccount is specified (not just being removed), that account must also sign the transaction.
	// Request is [ConsensusUpdateTopicTransactionBody](#proto.ConsensusUpdateTopicTransactionBody)
	UpdateTopic(context.Context, *Transaction) (*TransactionResponse, error)
	// Delete a topic. No more transactions or queries on the topic (via HAPI) will succeed.
	// If an adminKey is set, this transaction must be signed by that key.
	// If there is no adminKey, this transaction will fail UNAUTHORIZED.
	// Request is [ConsensusDeleteTopicTransactionBody](#proto.ConsensusDeleteTopicTransactionBody)
	DeleteTopic(context.Context, *Transaction) (*TransactionResponse, error)
	// Retrieve the latest state of a topic. This method is unrestricted and allowed on any topic by any payer account.
	// Deleted accounts will not be returned.
	// Request is [ConsensusGetTopicInfoQuery](#proto.ConsensusGetTopicInfoQuery)
	// Response is [ConsensusGetTopicInfoResponse](#proto.ConsensusGetTopicInfoResponse)
	GetTopicInfo(context.Context, *Query) (*Response, error)
	// Submit a message for consensus.
	// Valid and authorized messages on valid topics will be ordered by the consensus service, gossipped to the
	// mirror net, and published (in order) to all subscribers (from the mirror net) on this topic.
	// The submitKey (if any) must sign this transaction.
	// Request is [ConsensusSubmitMessageTransactionBody](#proto.ConsensusSubmitMessageTransactionBody)
	SubmitMessage(context.Context, *Transaction) (*TransactionResponse, error)
}

// UnimplementedConsensusServiceServer can be embedded to have forward compatible implementations.
type UnimplementedConsensusServiceServer struct {
}

func (*UnimplementedConsensusServiceServer) CreateTopic(ctx context.Context, req *Transaction) (*TransactionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateTopic not implemented")
}
func (*UnimplementedConsensusServiceServer) UpdateTopic(ctx context.Context, req *Transaction) (*TransactionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateTopic not implemented")
}
func (*UnimplementedConsensusServiceServer) DeleteTopic(ctx context.Context, req *Transaction) (*TransactionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteTopic not implemented")
}
func (*UnimplementedConsensusServiceServer) GetTopicInfo(ctx context.Context, req *Query) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTopicInfo not implemented")
}
func (*UnimplementedConsensusServiceServer) SubmitMessage(ctx context.Context, req *Transaction) (*TransactionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitMessage not implemented")
}

func RegisterConsensusServiceServer(s *grpc.Server, srv ConsensusServiceServer) {
	s.RegisterService(&_ConsensusService_serviceDesc, srv)
}

func _ConsensusService_CreateTopic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Transaction)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConsensusServiceServer).CreateTopic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.ConsensusService/CreateTopic",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConsensusServiceServer).CreateTopic(ctx, req.(*Transaction))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConsensusService_UpdateTopic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Transaction)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConsensusServiceServer).UpdateTopic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.ConsensusService/UpdateTopic",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConsensusServiceServer).UpdateTopic(ctx, req.(*Transaction))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConsensusService_DeleteTopic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Transaction)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConsensusServiceServer).DeleteTopic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.ConsensusService/DeleteTopic",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConsensusServiceServer).DeleteTopic(ctx, req.(*Transaction))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConsensusService_GetTopicInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Query)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConsensusServiceServer).GetTopicInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.ConsensusService/GetTopicInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConsensusServiceServer).GetTopicInfo(ctx, req.(*Query))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConsensusService_SubmitMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Transaction)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConsensusServiceServer).SubmitMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.ConsensusService/SubmitMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConsensusServiceServer).SubmitMessage(ctx, req.(*Transaction))
	}
	return interceptor(ctx, in, info, handler)
}

var _ConsensusService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "proto.ConsensusService",
	HandlerType: (*ConsensusServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "createTopic",
			Handler:    _ConsensusService_CreateTopic_Handler,
		},
		{
			MethodName: "updateTopic",
			Handler:    _ConsensusService_UpdateTopic_Handler,
		},
		{
			MethodName: "deleteTopic",
			Handler:    _ConsensusService_DeleteTopic_Handler,
		},
		{
			MethodName: "getTopicInfo",
			Handler:    _ConsensusService_GetTopicInfo_Handler,
		},
		{
			MethodName: "submitMessage",
			Handler:    _ConsensusService_SubmitMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ConsensusService.proto",
}
